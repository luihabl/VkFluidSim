#version 450
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : require

#include "common.glsl"
#include "spatial_hash.glsl"
#include "kernels_2d.glsl"

float PressureFromDensity(float density) {
    return (density - ubo.target_density) * ubo.pressure_multiplier;
}

float NearPressureFromDensity(float near_density) {
    return ubo.near_pressure_multiplier * near_density;
}

vec2 CalculatePressureForce(uint id) {
    
    float density = pc.densities.data[id].x;
    float density_near = pc.densities.data[id].y;
    float pressure = PressureFromDensity(density);
    float near_pressure = NearPressureFromDensity(density_near);
    vec2 pressure_force = vec2(0.0f);

    vec2 pos = ubo.predicted_positions.data[id];
    ivec2 origin_cell = GetCell2D(pos, ubo.smoothing_radius);
    float sqr_radius = ubo.smoothing_radius * ubo.smoothing_radius;

    for(int i = 0; i < 9; i++) {
        uint hash = HashCell2D(origin_cell + offsets_2d[i]);
        uint key = KeyFromHash(hash, pc.n_particles);
        uint curr_index = ubo.spatial_offsets.data[key];

        while(curr_index < pc.n_particles) {
            uint neighbor_index = curr_index;
            curr_index++;

            if(neighbor_index == id)
                continue;
            
            uint neighbor_key = ubo.spatial_keys.data[neighbor_index];

            if(neighbor_key != key)
                break;
            
            vec2 neighbor_pos = ubo.predicted_positions.data[neighbor_index]; 
            vec2 offset_to_neighbor = neighbor_pos - pos;
            float sqr_dst_to_neighbor = dot(offset_to_neighbor, offset_to_neighbor);

            if(sqr_dst_to_neighbor > sqr_radius)
                continue;

            float dst = sqrt(sqr_dst_to_neighbor); 
            vec2 dir_to_neighbor = dst > 0 ? offset_to_neighbor / dst : vec2(0, 1);

            float neighbor_density = pc.densities.data[neighbor_index].x;
            float neighbor_near_density = pc.densities.data[neighbor_index].y;
            float neighbor_pressure = PressureFromDensity(neighbor_density);
            float neighbor_near_pressure = NearPressureFromDensity(neighbor_near_density);

            float shared_pressure = (pressure + neighbor_pressure) * 0.5f;
            float shared_near_pressure = (pressure + neighbor_near_pressure) * 0.5f;

            pressure_force += dir_to_neighbor * DensityDerivative(dst, ubo.smoothing_radius) * shared_pressure / neighbor_density;
            pressure_force += dir_to_neighbor * NearDensityDerivative(dst, ubo.smoothing_radius) * shared_near_pressure / neighbor_near_density;
        }
    }

    return pressure_force / density;
}

layout (local_size_x = nThreads, local_size_y = 1, local_size_z = 1) in;
void main() {
    uint id = gl_GlobalInvocationID.x;
    if(id >= pc.n_particles)
        return;

   vec2 acc = CalculatePressureForce(id);
   pc.velocities.data[id] += acc * pc.dt;
}
